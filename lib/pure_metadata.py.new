"""
Pure Python metadata handling module.
This module uses pyexiv2 to handle all types of metadata (EXIF, XMP, IPTC) when available.
"""

import os
import sys
import datetime
import piexif
import cv2
import shutil

# Try to import pyexiv2
pyexiv2 = None

try:
    import pyexiv2
    print("Imported pyexiv2 module successfully")
except ImportError:
    print("Warning: pyexiv2 not installed. Some metadata functionality will be limited.")
    print("To install: pip install pyexiv2")

def is_exiv2_available():
    """Check if pyexiv2 module is available."""
    return pyexiv2 is not None

def set_basic_exif_metadata(image_path, image_title, photographer_name, institution_name, copyright_text, image_dpi):
    """
    Set basic EXIF metadata using piexif (fallback method).
    This is used when pyexiv2 is not available.
    Works with both TIFF and JPEG files.
    """
    try:
        # Check if file exists
        if not os.path.exists(image_path):
            print(f"      Error: File not found: {image_path}")
            return False
            
        # File extension check
        file_ext = os.path.splitext(image_path.lower())[1]
        is_jpeg = file_ext in ['.jpg', '.jpeg']
        is_tiff = file_ext in ['.tif', '.tiff']
        
        if not (is_jpeg or is_tiff):
            print(f"      Warning: Unsupported file format for piexif: {file_ext}")
            return False
        
        # Create a clean EXIF dictionary
        exif_dictionary = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}
        
        # Set metadata fields with error handling
        try:
            exif_dictionary["0th"][piexif.ImageIFD.Artist] = f"{photographer_name} ({institution_name})".encode('utf-8')
            exif_dictionary["0th"][piexif.ImageIFD.Copyright] = copyright_text.encode('utf-8')
            # Additional copyright tag for some readers
            exif_dictionary["0th"][40095] = copyright_text.encode('utf-8')
            exif_dictionary["0th"][piexif.ImageIFD.ImageDescription] = image_title.encode('utf-8')
            exif_dictionary["0th"][piexif.ImageIFD.Software] = "eBL Photo Stitcher".encode('utf-8')
            exif_dictionary["0th"][piexif.ImageIFD.XResolution] = (image_dpi, 1)
            exif_dictionary["0th"][piexif.ImageIFD.YResolution] = (image_dpi, 1)
            exif_dictionary["0th"][piexif.ImageIFD.ResolutionUnit] = 2  # Inches
            
            # Additional metadata for Title field (some viewers use this)
            exif_dictionary["0th"][270] = image_title.encode('utf-8')  # Image Description
            
            # Dump exif data with enhanced error handling
            exif_bytes = piexif.dump(exif_dictionary)
            
            if is_jpeg:
                try:
                    piexif.insert(exif_bytes, image_path)
                    print(f"      EXIF metadata applied successfully to {os.path.basename(image_path)} via piexif.")
                    return True
                except Exception as insert_err:
                    print(f"      Alternative method for JPEG metadata...")
                    # Read the image and write it back with metadata
                    img = cv2.imread(image_path)
                    if img is not None:
                        temp_path = f"{image_path}.temp"
                        if cv2.imwrite(temp_path, img, [cv2.IMWRITE_JPEG_QUALITY, 95]):
                            try:
                                piexif.insert(exif_bytes, temp_path)
                                os.remove(image_path)
                                os.rename(temp_path, image_path)
                                print(f"      EXIF metadata applied successfully via alternative method.")
                                return True
                            except Exception as alt_err:
                                print(f"      Error with alternative method: {alt_err}")
                                if os.path.exists(temp_path):
                                    os.remove(temp_path)
                                return False
            elif is_tiff:
                # For TIFF files, we need to use a different approach
                # First, clean any existing metadata
                clean_image_metadata(image_path)
                
                # Create a temporary file with metadata
                temp_path = f"{image_path}.temp"
                try:
                    # Read the image
                    img = cv2.imread(image_path)
                    if img is None:
                        print(f"      Error: Could not read TIFF image: {image_path}")
                        return False
                    
                    # Write to temp with compression 1 (none or minimal)
                    cv2.imwrite(temp_path, img, [cv2.IMWRITE_TIFF_COMPRESSION, 1])
                    
                    # Try to add EXIF data if this is a JPEG-compatible TIFF
                    try:
                        piexif.insert(exif_bytes, temp_path)
                    except:
                        print(f"      Could not insert EXIF into TIFF with piexif, will try an alternative method")
                    
                    # Replace the original
                    if os.path.exists(temp_path):
                        os.remove(image_path)
                        os.rename(temp_path, image_path)
                        print(f"      Basic metadata applied to TIFF: {os.path.basename(image_path)}")
                        return True
                except Exception as tiff_err:
                    print(f"      Error applying basic metadata to TIFF: {tiff_err}")
                    if os.path.exists(temp_path):
                        os.remove(temp_path)
                    return False
                
        except Exception as field_error:
            print(f"      Warn: Error setting specific EXIF field: {field_error}")
            return False
    except Exception as e: 
        print(f"      Warn: piexif metadata error: {e}")
        return False

def clean_image_metadata(image_path):
    """Clean problematic metadata like shape data from the image"""
    try:
        # Create a temporary file path
        temp_file = image_path + ".tmp"
        
        # Read and write the image to clean metadata
        img = cv2.imread(image_path)
        if img is None:
            print(f"      Warning: Could not read image to clean metadata: {image_path}")
            return False
            
        # Save with appropriate parameters based on file type
        file_ext = os.path.splitext(image_path.lower())[1]
        if file_ext in ['.tif', '.tiff']:
            cv2.imwrite(temp_file, img, [cv2.IMWRITE_TIFF_COMPRESSION, 1])
        elif file_ext in ['.jpg', '.jpeg']:
            cv2.imwrite(temp_file, img, [cv2.IMWRITE_JPEG_QUALITY, 95])
        else:
            cv2.imwrite(temp_file, img)
            
        if os.path.exists(temp_file):
            # Replace original with cleaned version
            os.remove(image_path)
            os.rename(temp_file, image_path)
            print(f"      Successfully cleaned image metadata.")
            return True
        return False
    except Exception as clean_err:
        print(f"      Warning: Failed to clean image metadata: {clean_err}")
        # If temp file exists but something failed, try to clean up
        try:
            if os.path.exists(temp_file):
                os.remove(temp_file)
        except:
            pass
        return False

def _special_clean_tiff_for_metadata(image_path):
    """Special cleaning for TIFF files to ensure metadata can be applied"""
    try:
        print(f"      Performing special TIFF cleaning for {os.path.basename(image_path)}...")
        # Create a temporary file path
        temp_file = image_path + ".tmp"
        
        # Read the image with OpenCV
        img = cv2.imread(image_path)
        if img is None:
            print(f"      Error: Could not read TIFF image: {image_path}")
            return False
        
        # Write to temp with no compression
        cv2.imwrite(temp_file, img, [cv2.IMWRITE_TIFF_COMPRESSION, 1])
        
        if os.path.exists(temp_file):
            # Replace original with cleaned version
            os.remove(image_path)
            os.rename(temp_file, image_path)
            print(f"      Special TIFF cleaning completed successfully.")
            return True
        else:
            print("      Failed to create cleaned TIFF file.")
            return False
    except Exception as e:
        print(f"      Error in special TIFF cleaning: {e}")
        # If temp file exists but something failed, try to clean up
        try:
            if os.path.exists(temp_file):
                os.remove(temp_file)
        except:
            pass
        return False

def apply_all_metadata(
    image_path, 
    image_title, 
    photographer_name, 
    institution_name,
    credit_line_text, 
    copyright_text, 
    usage_terms_text=None, 
    image_dpi=600
):
    """
    Apply all metadata (EXIF, XMP, IPTC) using pyexiv2 when available.
    Falls back to piexif for basic EXIF if pyexiv2 is not available.
    Works with both TIFF and JPG files.
    
    Returns True if successful, False otherwise.
    """
    if not os.path.exists(image_path):
        print(f"Error: File not found: {image_path}")
        return False
    
    file_ext = os.path.splitext(image_path.lower())[1]
    is_tiff = file_ext in ('.tif', '.tiff')
    is_jpeg = file_ext in ('.jpg', '.jpeg')
    
    if not (is_tiff or is_jpeg):
        print(f"Warning: Unsupported file format: {file_ext}. Only TIFF and JPEG are supported.")
        return False
    
    print(f"    Setting metadata for: {os.path.basename(image_path)}")
    
    # Try to fix any problematic metadata first
    try:
        if is_tiff:
            # TIFF files often need special handling
            with open(image_path, 'rb') as f:
                file_start = f.read(1000)  # Read first 1000 bytes to check
                if b'{"shape"' in file_start:
                    print("      Detected problematic shape data, cleaning...")
                    clean_image_metadata(image_path)
            
            # Special cleaning for TIFF files
            _special_clean_tiff_for_metadata(image_path)
    except Exception as e:
        print(f"      Warning: Error checking for shape data: {e}")
    
    # If pyexiv2 module is available, use it for comprehensive metadata handling
    if pyexiv2:
        try:
            print(f"      Using pyexiv2 for advanced metadata...")
            
            # Make a backup copy just in case
            backup_path = None
            try:
                backup_path = image_path + ".backup"
                shutil.copy2(image_path, backup_path)
            except Exception as backup_err:
                print(f"      Warning: Could not create backup: {backup_err}")
                backup_path = None
            
            # Method 1: Using pyexiv2.Image - newer API style
            try:
                # Check if this version of pyexiv2 supports the Image class
                if hasattr(pyexiv2, 'Image'):
                    print("      Using pyexiv2.Image API")
                    metadata = pyexiv2.Image(image_path)
                    
                    # Build EXIF dictionary
                    exif_dict = {
                        'Exif.Image.Artist': f"{photographer_name} ({institution_name})",
                        'Exif.Image.Copyright': copyright_text,
                        'Exif.Image.ImageDescription': image_title,
                        'Exif.Image.Software': "eBL Photo Stitcher",
                        'Exif.Image.XResolution': (image_dpi, 1),
                        'Exif.Image.YResolution': (image_dpi, 1),
                        'Exif.Image.ResolutionUnit': 2  # Inches
                    }
                    
                    # Build XMP dictionary
                    xmp_dict = {
                        'Xmp.dc.title': image_title,
                        'Xmp.dc.creator': photographer_name,  # String not list for compatibility
                        'Xmp.dc.rights': copyright_text,
                        'Xmp.dc.description': image_title,
                        'Xmp.photoshop.Credit': credit_line_text,
                        'Xmp.photoshop.Source': institution_name,
                        'Xmp.xmpRights.Marked': "True"  # String not boolean for compatibility
                    }
                    
                    # Try to add subject as a string (more compatible)
                    xmp_dict['Xmp.dc.subject'] = f"cuneiform, tablet, {institution_name}"
                        
                    if usage_terms_text:
                        xmp_dict['Xmp.xmpRights.UsageTerms'] = usage_terms_text
                        
                    # Add date
                    xmp_dict['Xmp.xmp.MetadataDate'] = datetime.datetime.now().isoformat()
                    
                    # Apply metadata with appropriate method
                    if hasattr(metadata, 'modify_exif'):
                        metadata.modify_exif(exif_dict)
                    else:
                        # Direct property assignment
                        for key, value in exif_dict.items():
                            try:
                                metadata[key] = value
                            except Exception as key_err:
                                print(f"      Warning: Couldn't set {key}: {key_err}")
                    
                    if hasattr(metadata, 'modify_xmp'):
                        metadata.modify_xmp(xmp_dict)
                    else:
                        # Direct property assignment for XMP
                        for key, value in xmp_dict.items():
                            try:
                                metadata[key] = value
                            except Exception as key_err:
                                print(f"      Warning: Couldn't set {key}: {key_err}")
                    
                    # Save changes
                    if hasattr(metadata, 'save_file'):
                        metadata.save_file()
                    elif hasattr(metadata, 'save'):
                        metadata.save()
                    else:
                        print("      Warning: Could not determine how to save metadata with this API")
                        raise Exception("Unknown save method for this pyexiv2 version")
                    
                    print(f"      Metadata successfully applied with pyexiv2.Image API")
                    return True
                else:
                    raise AttributeError("pyexiv2.Image not found")
            
            except (AttributeError, Exception) as modern_api_err:
                # If Image class is not available, try with ImageMetadata
                print(f"      Newer API failed ({modern_api_err}), trying ImageMetadata API")
                
                if hasattr(pyexiv2, 'ImageMetadata'):
                    print("      Using pyexiv2.ImageMetadata API")
                    
                    # Special handling for TIFF files - clean again if needed
                    if is_tiff:
                        _special_clean_tiff_for_metadata(image_path)
                    
                    metadata = pyexiv2.ImageMetadata(image_path)
                    metadata.read()
                    
                    # Clear existing metadata (optional, but helps avoid conflicts)
                    try:
                        if hasattr(metadata, 'clear'):
                            metadata.clear()
                        else:
                            # Manual clearing
                            for key in list(metadata.exif_keys):
                                try:
                                    del metadata[key]
                                except:
                                    pass
                            for key in list(metadata.iptc_keys):
                                try:
                                    del metadata[key]
                                except:
                                    pass
                            for key in list(metadata.xmp_keys):
                                try:
                                    del metadata[key]
                                except:
                                    pass
                    except Exception as clear_err:
                        print(f"      Warning: Could not clear existing metadata: {clear_err}")
                    
                    # Set EXIF metadata
                    metadata['Exif.Image.Artist'] = f"{photographer_name} ({institution_name})"
                    metadata['Exif.Image.Copyright'] = copyright_text
                    metadata['Exif.Image.ImageDescription'] = image_title
                    metadata['Exif.Image.Software'] = "eBL Photo Stitcher"
                    
                    # Handle resolution
                    try:
                        if hasattr(pyexiv2, 'Rational'):
                            metadata['Exif.Image.XResolution'] = pyexiv2.Rational(image_dpi, 1)
                            metadata['Exif.Image.YResolution'] = pyexiv2.Rational(image_dpi, 1)
                        else:
                            metadata['Exif.Image.XResolution'] = (image_dpi, 1)
                            metadata['Exif.Image.YResolution'] = (image_dpi, 1)
                    except:
                        # If setting resolution fails, try as integers
                        metadata['Exif.Image.XResolution'] = image_dpi
                        metadata['Exif.Image.YResolution'] = image_dpi
                        
                    metadata['Exif.Image.ResolutionUnit'] = 2  # Inches
                    
                    # Set XMP metadata (Dublin Core)
                    metadata['Xmp.dc.title'] = image_title
                    
                    # Handle creator (some versions expect string, others list)
                    try:
                        metadata['Xmp.dc.creator'] = [photographer_name]
                    except:
                        try:
                            metadata['Xmp.dc.creator'] = photographer_name
                        except Exception as creator_err:
                            print(f"      Warning: Could not set dc.creator: {creator_err}")
                    
                    metadata['Xmp.dc.rights'] = copyright_text
                    metadata['Xmp.dc.description'] = image_title
                    
                    # Set subjects/keywords - try both formats
                    try:
                        metadata['Xmp.dc.subject'] = f"cuneiform, tablet, {institution_name}"
                    except:
                        try:
                            metadata['Xmp.dc.subject'] = ["cuneiform", "tablet", institution_name]
                        except Exception as subject_err:
                            print(f"      Warning: Could not set dc.subject: {subject_err}")
                    
                    # Set XMP metadata (Photoshop)
                    metadata['Xmp.photoshop.Credit'] = credit_line_text
                    metadata['Xmp.photoshop.Source'] = institution_name
                    
                    # Set XMP Rights Management metadata
                    try:
                        metadata['Xmp.xmpRights.Marked'] = True
                    except:
                        try:
                            metadata['Xmp.xmpRights.Marked'] = "True"
                        except Exception as rights_err:
                            print(f"      Warning: Could not set xmpRights.Marked: {rights_err}")
                            
                    if usage_terms_text:
                        metadata['Xmp.xmpRights.UsageTerms'] = usage_terms_text
                    
                    # Add additional metadata
                    metadata['Xmp.xmp.MetadataDate'] = datetime.datetime.now().isoformat()
                    
                    # Write changes to file
                    metadata.write()
                    print(f"      All metadata applied successfully with ImageMetadata API")
                    return True
                else:
                    raise Exception("Neither pyexiv2.Image nor pyexiv2.ImageMetadata is available")
            
        except Exception as e:
            print(f"      Error applying metadata with pyexiv2: {e}")
            
            # If we had a backup and the operation failed, restore it
            if backup_path and os.path.exists(backup_path):
                try:
                    print("      Restoring backup due to metadata error...")
                    if os.path.exists(image_path):
                        os.remove(image_path)
                    shutil.copy2(backup_path, image_path)
                    os.remove(backup_path)
                except:
                    pass
                    
            # Special handling for TIFF files - they often need direct modification
            if is_tiff:
                print("      Trying special TIFF metadata handling...")
                # For TIFF, fallback to special handling with piexif + cv2
                return set_basic_exif_metadata(
                    image_path, image_title, photographer_name, 
                    institution_name, copyright_text, image_dpi
                )
            else:
                # For JPEG, fall back to piexif for basic EXIF
                print("      Falling back to piexif for basic EXIF...")
                return set_basic_exif_metadata(
                    image_path, image_title, photographer_name, 
                    institution_name, copyright_text, image_dpi
                )
    else:
        # Fall back to piexif for basic EXIF
        print("      No advanced metadata modules available, using piexif for basic EXIF.")
        return set_basic_exif_metadata(
            image_path, image_title, photographer_name, 
            institution_name, copyright_text, image_dpi
        )
