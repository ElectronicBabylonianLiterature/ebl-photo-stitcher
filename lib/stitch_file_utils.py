import os
import cv2
try:
    from image_utils import convert_to_bgr_if_needed
except ImportError:
    print("FATAL ERROR: stitch_file_utils.py cannot import from image_utils.py")
    def convert_to_bgr_if_needed(img): return img # Fallback

OBJECT_FILE_SUFFIX = "_object.tif"
SCALED_RULER_FILE_SUFFIX = "_07.tif" # Assuming this is the final scaled ruler

def find_processed_image_file(subfolder_path, base_name, view_specific_part, general_suffix):
    target_filename = f"{base_name}{view_specific_part}{general_suffix}"
    path = os.path.join(subfolder_path, target_filename)
    if os.path.exists(path): return path
    if view_specific_part.startswith("_0") and len(view_specific_part) == 3: # e.g., "_01"
        alt_part = "_" + view_specific_part[2] # e.g., "_1"
        alt_filename = f"{base_name}{alt_part}{general_suffix}"
        alt_path = os.path.join(subfolder_path, alt_filename)
        if os.path.exists(alt_path): return alt_path
    return None

def load_images_for_stitching_process(subfolder_path, image_base_name, view_to_file_pattern_map, custom_layout=None):
    loaded_image_arrays = {}
    
    # Define a helper to load a single image array
    def _load_image(file_path, view_key_for_log):
        img_arr = None
        if file_path and os.path.exists(file_path):
            raw_image_array = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
            if raw_image_array is not None:
                img_arr = convert_to_bgr_if_needed(raw_image_array)
                if img_arr is not None:
                    print(f"      Stitch - Loaded {view_key_for_log}: {os.path.basename(file_path)}")
                else:
                    print(f"      Warn: Stitch - Failed to convert/process {view_key_for_log} from {file_path}")
            else:
                print(f"      Warn: Stitch - Failed to load {view_key_for_log} from {file_path}")
        else:
            print(f"      Warn: Stitch - {view_key_for_log} file not found at: {file_path}")
        return img_arr

    if custom_layout:
        print(f"      Stitch - Using custom layout for image loading: {custom_layout.keys()}")
        for view_key, path_data in custom_layout.items():
            if isinstance(path_data, str): # Single image path from custom layout
                # Paths in custom_layout are original source file paths.
                # We need to find the corresponding '_object.tif' generated by object_extractor.
                # These are expected to be in the subfolder_path.
                original_basename = os.path.splitext(os.path.basename(path_data))[0]
                object_file_to_load = os.path.join(subfolder_path, f"{original_basename}{OBJECT_FILE_SUFFIX}")
                loaded_image_arrays[view_key] = _load_image(object_file_to_load, view_key)
            elif isinstance(path_data, list): # List of image paths for a sequence
                sequence_images = []
                for i, single_path_in_seq in enumerate(path_data):
                    if not single_path_in_seq: continue # Skip if path is empty
                    original_basename_seq = os.path.splitext(os.path.basename(single_path_in_seq))[0]
                    object_file_to_load_seq = os.path.join(subfolder_path, f"{original_basename_seq}{OBJECT_FILE_SUFFIX}")
                    img_arr = _load_image(object_file_to_load_seq, f"{view_key}_item_{i+1}")
                    if img_arr is not None:
                        sequence_images.append(img_arr)
                if sequence_images: # Only add if we actually loaded some images for the sequence
                    loaded_image_arrays[view_key] = sequence_images
                else:
                    loaded_image_arrays[view_key] = None # Or an empty list, depending on downstream handling
                    print(f"      Warn: Stitch - No images loaded for sequence {view_key}")
            else:
                print(f"      Warn: Stitch - Unexpected data type in custom_layout for key {view_key}: {type(path_data)}")
                loaded_image_arrays[view_key] = None


    # Fallback or supplement with pattern-based loading for views not in custom_layout (e.g., ruler)
    # or if custom_layout was not provided at all.
    for view_name_key, filename_pattern_part in view_to_file_pattern_map.items():
        if custom_layout and view_name_key in custom_layout:
            # This view was already handled by custom_layout, skip pattern search for it.
            # However, ensure it's actually in loaded_image_arrays if custom_layout processing failed for it.
            if view_name_key not in loaded_image_arrays:
                 loaded_image_arrays[view_name_key] = None # Explicitly mark as not found if custom load failed
            continue

        image_file_path = None
        if view_name_key == "ruler":
            # Ruler uses a different naming convention: base_name + _07.tif (or SCALED_RULER_FILE_SUFFIX)
            # The image_base_name here is the subfolder name.
            image_file_path = find_processed_image_file(subfolder_path, image_base_name, "", SCALED_RULER_FILE_SUFFIX)
        else:
            # Standard views are expected as: image_base_name + view_pattern_part + _object.tif
            image_file_path = find_processed_image_file(subfolder_path, image_base_name, filename_pattern_part, OBJECT_FILE_SUFFIX)
        
        loaded_image_arrays[view_name_key] = _load_image(image_file_path, view_name_key)
        
    return loaded_image_arrays
